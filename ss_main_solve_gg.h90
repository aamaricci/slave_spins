function ss_solve_lambda(lambda) result(fss)
  real(8),dimension(:),intent(in) :: lambda
  real(8),dimension(size(lambda)) :: fss
  integer                         :: iter,Nsuccess=0
  logical                         :: z_converged,bool
  real(8)                         :: zeta(Ns),Fzeta(Ns)
  !
  bool = size(lambda)==Nso+1
  !
  ss_lambda(:Nso) = lambda(1:Nso)
  if(bool)xmu     = lambda(Nso+1)
  if(Nspin==1)call ss_spin_symmetry(ss_lambda)
  !
  if(zeta_restart_init)ss_zeta = ss_zeta_init
  !
  if(verbose>2)call start_timer()
  z_converged=.false. ; iter=0
  do while(.not.z_converged.AND.iter<=loop_Nitermax)
     iter=iter+1
     call start_loop(iter,loop_Nitermax,"Z-iter")
     !
     zeta = ss_zeta
     call ss_solve_fermions
     call ss_solve_spins
     if(verbose>3)write(*,"(A6,12G18.9)")"mu   =",xmu
     if(verbose>3)write(*,"(A6,12G18.9)")"C    =",ss_c
     if(verbose>2)write(*,"(A6,12G18.9)")"N    =",ss_dens(:Nso),sum(ss_dens),filling
     if(verbose>2)write(*,"(A6,12G18.9)")"Z_ss =",ss_zeta(:Nso)
     Fzeta= ss_zeta - zeta
     !
     select case(loop_MixType)
     case ("linear")            
        call linear_mix(ss_zeta,Fzeta,loop_Wmix)
     case ("adaptive")
        call adaptive_mix(ss_zeta,Fzeta,loop_Wmix,iter)
     case default
        call broyden_mix(zeta,Fzeta,loop_Wmix,loop_Nmix,iter)
     end select
     !
     z_converged = check_convergence_local(ss_zeta-zeta,loop_tolerance,Nsuccess,loop_Nitermax)
     call end_loop() 
  end do
  !
  !<constraint:
  fss = ss_Dens - (ss_Sz + 0.5d0)
  if(bool)fss(Nso+1) = sum(ss_Dens) - filling
  !
  if(verbose>1)then
     write(*,"(A7,12G18.9)")"Dens  =",ss_dens(:Nso)
     write(*,"(A7,12G18.9)")"Sz+1/2=",ss_Sz(:Nso)+0.5d0
     write(*,*)""
     write(*,"(A7,12G18.9)")"Lambda=",lambda(:Nso)
     write(*,"(A7,12G18.9)")"F_ss  =",fss(:Nso)
     if(verbose>2)call stop_timer()
     write(*,*)""
     write(*,*)""
  endif
  !
  call ss_write_all()
  !
end function ss_solve_lambda
